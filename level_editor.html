<!DOCTYPE html>
<html>
    <head>
        <title>Level Editor</title>
        <meta charset="utf-8" />
        <style>
            html, body {
                position: absolute;
                top: 0; left: 0;
                width: 100%; height: 100%;
                margin: 0; border: 0; padding: 0;
                font-family: "Arial", "Helvetica", sans-serif;
                font-size: 13pt;
            }
            
            #editor-wrapper {
                width: 664px; height: 552px;
                /* so much work just to center a div on a screen
                   you'd think that the w3c would at least provide a
                   "position: center" option or something like that
                */
                position: absolute;
                top: 0; left: 0; bottom: 0; right: 0;
                margin: auto;
            }
            
            #editor-controls {
                width: 100px; /* height: 550px; */
                display: inline-block;
                border: 1px solid teal;
                margin: 0;
                top: 0; left: 0;
                position: absolute;
                border-radius: 5px;
            }
            
            #add-remove {
                border-bottom: 1px solid teal;
            }
            
            #display-wrapper {
                width: 550px; height: 550px;
                display: inline-block;
                border: 1px solid dodgerblue;
                padding: 0;
                position: absolute;
                left: 104px;
                border-radius: 5px;
            }
            
            #display {
                width: 550px; height: 550px;
                background-color: dodgerblue;
                margin: 0; border: 0;
            }
            
            button {
                width: 90%;
                margin-left: 4%;
                max-width: 90%;
                color: midnightblue;
                border: 1px solid midnightblue;
                background-color: white;
                transition: background-color 0.5s, color 0.5s;
                margin-top: 3px;
                margin-bottom: 3px;
                padding-top: 3px;
                padding-bottom: 3px;
                border-radius: 20px;
            }
            
            button:hover {
                background-color: midnightblue;
                color: white;
                transition: background-color 0.5s, color 0.5s;
            }
            
            button:disabled {
                background-color: white;
                color: dimgray;
                border-color: dimgray;
                transition: background-color 0.5s, color 0.5s;
            }
            
            button#test_level, button#export {
                color: forestgreen;
                background-color: white;
                border-color: forestgreen;
            }
            
            button.selected {
                background-color: black;
                color: white;
                border-color: black;
                transition: background-color 0.5s, color 0.5s;
            }
            
            button#test_level:hover, button#export:hover {
                color: white;
                background-color: forestgreen;
            }
            
            button#test_level:disabled {
                color: dimgray;
                background-color: white;
                border-color: dimgray;
                transition: background-color 0.5s, color 0.5s;
            }
            
            button.close {
                width: 90px;
                color: firebrick;
                background-color: white;
                border-color: firebrick;
            }
            
            button.close:hover {
                color: white;
                background-color: firebrick;
            }
            
            .export-dialog {
                width: 550px; height: 550px;
                border: 1px solid black;
                background-color: white;
                position: absolute;
                top: 0; left: 0; right: 0; bottom: 0;
                margin: auto;
                z-index: 1;
                overflow: hidden;
            }
            
            .export-text {
                width: 540px; height: 500px;
                margin: 5px;
                overflow-y: scroll;
                overflow-x: wbr;
                color: black;
                font-family: monospace;
            }
        </style>
    </head>
    <body>
        <!-- more divsoup! wheeeeeeeeeee! -->
        <div id="editor-wrapper">
            <div id="editor-controls">
                <div id="add-remove">
                    <button id="add_wall" class="selected">wall</button>
                    <button id="add_trap">trap</button>
                    <button id="add_coin">coin</button>
                    <button id="add_goal">goal</button>
                    <button id="add_player">player</button>
                    <button id="remove">erase</button>
                </div>
                <button id="test_level">test</button>
                <button id="export">export</button>
            </div>
            <div id="display-wrapper">
                <canvas id="display"><canvas>
            </div>
        </div>
        <script>
            // too lazy to put the script in a separate file
            // enjoy your huge script inside an HTML tree
            
            var click_action = "add_wall";
            // create the rbutton group
            (function(parent, callback) {
                var buttons = parent.childNodes;
                buttons.forEach(b => {
                    b.addEventListener("click", () => {
                        buttons.forEach(u => {
                            // don't you love nesting functions inside functions inside functions?
                            u.className = "";
                        });
                        b.className = "selected";
                        callback(b.id);
                    });
                });
            })(document.getElementById("add-remove"), (data) => { click_action = data; });
            
            var map = {
                width: Number(prompt("how many columns?", 50)),
                height: Number(prompt("how many rows?", 30)),
                tiles: [],
            };
            
            for (var h = 0; h < map.height; h++) {
                map.tiles[h] = Array(map.width).fill(null);
            }
            
            var canvas   = document.querySelector("canvas");
            var context  = canvas.getContext("2d");
            canvas.width = 550, canvas.height = 550;
            
            var mouse_pos = { x: null, y: null };
            var clicking  = false;
            
            canvas.addEventListener("mousemove", (evt) => {
                mouse_pos.x = evt.offsetX, mouse_pos.y = evt.offsetY;
            });
            
            canvas.addEventListener("mousedown", (evt) => {
                clicking = true;
            });
            
            canvas.addEventListener("mouseup", (evt) => {
                clicking = false;
            });
            
            // colours!
            var wall_colour   = "white";
            var trap_colour   = "indianred";
            var goal_colour   = "mediumspringgreen";
            var coin_colour   = "yellow";
            var player_colour = "forestgreen";
            
            var scale = 30;
            
            var viewport = {
                scale: scale,
                top: 0, left: 0,
                width: canvas.width / this.scale, height: canvas.height / this.scale,
                
                update: function() {
                    var left_margin = this.left + this.width * 0.1, right_margin  = this.left + this.width * 0.9;
                    var top_margin  = this.top + this.height * 0.1, bottom_margin = this.top + this.height * 0.9;
                    
                    var mouse = {
                        x: mouse_pos.x / this.scale + this.left,
                        y: mouse_pos.y / this.scale + this.top,
                    };
                    
                    var scrolling_factor = 0.0005;
                    
                    if (mouse.x < left_margin) {
                        this.left += (left_margin - mouse_pos.x) * scrolling_factor * 10;
                    }
                    if (mouse.x > right_margin) {
                        this.left += (mouse_pos.x - right_margin) * scrolling_factor;
                    }
                    
                    if (mouse.y < top_margin) {
                        this.top += (top_margin - mouse_pos.y) * scrolling_factor * 10;
                    }
                    if (mouse.y > bottom_margin) {
                        this.top += (mouse_pos.y - bottom_margin) * scrolling_factor;
                    }
                    
                    this.left = Math.min(map.width - this.width, Math.max(this.left, 0));
                    this.top  = Math.min(map.height - this.height, Math.max(this.top, 0));
                },
                
                draw: function() {
                    // clear the screen first
                    context.clearRect(0, 0, 550, 550);
                    
                    /*
                    var start_x = Math.max(Math.min(map.width, Math.floor(this.left)), 0);
                    var end_x   = Math.max(Math.min(map.width, Math.ceil(this.left + this.width)), 0);
                    var start_y = Math.max(Math.min(map.height, Math.floor(this.top)), 0);
                    var end_y   = Math.max(Math.min(map.height, Math.ceil(this.top + this.height)), 0);
                    */
                    
                    var start_x = Math.floor(this.left);
                    var end_x   = Math.ceil(this.left + this.width);
                    var start_y = Math.floor(this.top);
                    var end_y   = Math.ceil(this.top + this.height);
                    
                    for (var y = start_y; y < end_y; y++) {
                        var gridline = map.tiles[y];
                        if (gridline == null) continue;
                        for (var x = start_x; x < end_x; x++) {
                            if (gridline[x] == null) continue;
                            var screen_x = (x - this.left) * this.scale, screen_y = (y - this.top) * this.scale;
                            switch (gridline[x]) {
                                case "wall":
                                    context.fillStyle = wall_colour;
                                    context.fillRect(screen_x, screen_y, this.scale, this.scale);
                                    break;
                                case "u-trap":
                                    context.fillStyle = trap_colour;
                                    // draw a triangle, facing the same direction as the trap
                                    context.beginPath();
                                    context.moveTo(screen_x, screen_y + this.scale);
                                    context.lineTo(screen_x + this.scale / 2, screen_y);
                                    context.lineTo(screen_x + this.scale, screen_y + this.scale);
                                    context.closePath();
                                    context.fill();
                                    break;
                                case "d-trap":
                                    context.fillStyle = trap_colour;
                                    // draw a triangle, facing the same direction as the trap
                                    context.beginPath();
                                    context.moveTo(screen_x, screen_y);
                                    context.lineTo(screen_x + this.scale / 2, screen_y + this.scale);
                                    context.lineTo(screen_x + this.scale, screen_y);
                                    context.closePath();
                                    context.fill();
                                    break;
                                case "l-trap":
                                    context.fillStyle = trap_colour;
                                    // draw a triangle, facing the same direction as the trap
                                    context.beginPath();
                                    context.moveTo(screen_x, screen_y);
                                    context.lineTo(screen_x + this.scale, screen_y + this.scale / 2);
                                    context.lineTo(screen_x, screen_y + this.scale);
                                    context.closePath();
                                    context.fill();
                                    break;
                                case "r-trap":
                                    context.fillStyle = trap_colour;
                                    // draw a triangle, facing the same direction as the trap
                                    context.beginPath();
                                    context.moveTo(screen_x + this.scale, screen_y);
                                    context.lineTo(screen_x, screen_y + this.scale / 2);
                                    context.lineTo(screen_x + this.scale, screen_y + this.scale);
                                    context.closePath();
                                    context.fill();
                                    break;
                                case "coin":
                                    context.fillStyle = coin_colour;
                                    context.fillRect(screen_x + this.scale / 3, screen_y + this.scale / 3, this.scale / 3, this.scale / 3);
                                    break;
                                case "goal":
                                    context.fillStyle = goal_colour;
                                    context.fillRect(screen_x + this.scale / 4, screen_y + this.scale / 4, this.scale / 2, this.scale / 2);
                                    break;
                                case "player":
                                    context.fillStyle = player_colour;
                                    context.fillRect(screen_x, screen_y - this.scale, this.scale, this.scale * 2);
                                    break;
                            }
                        }
                    }
                },
                
                get_map_coords: function() {
                    return {
                        x: Math.floor(mouse_pos.x / this.scale + this.left),
                        y: Math.floor(mouse_pos.y / this.scale + this.top),
                    };
                },
            };
            
            function animate() {
                viewport.update();
                
                if (clicking) place();
                
                viewport.draw();
                
                requestAnimationFrame(animate);
            }
            
            function place() {
                var mouse = viewport.get_map_coords();
                if (mouse.x >= 0 && mouse.x < map.width &&
                    mouse.y >= 0 && mouse.y < map.height
                ) {
                    map.tiles[mouse.y][mouse.x] = (() => {
                        switch (click_action) {
                            case "add_wall":
                                if (map.tiles[mouse.y][mouse.x] == "goal") return "goal";
                                if (map.tiles[mouse.y][mouse.x] == "player") return "player";
                                return "wall";
                            case "add_trap":
                                // priority: up, down, right, left
                                if (map.tiles[mouse.y + 1][mouse.x] == "wall") {
                                    return "u-trap";
                                }
                                if (map.tiles[mouse.y - 1][mouse.x] == "wall") {
                                    return "d-trap";
                                }
                                if (map.tiles[mouse.y][mouse.x + 1] == "wall") {
                                    return "r-trap";
                                }
                                if (map.tiles[mouse.y][mouse.x - 1] == "wall") {
                                    return "l-trap";
                                }
                                return "u-trap";
                            case "add_coin":
                                return "coin";
                            case "add_goal":
                                document.getElementById("add_wall").click();
                                return "goal";
                            case "add_player":
                                document.getElementById("add_wall").click();
                                return "player";
                            case "remove":
                                return null;
                            default:
                                return "wall";
                        }
                    })();
                    
                    document.getElementById("add_player").disabled = map_has("player");
                    document.getElementById("add_goal").disabled   = map_has("goal");
                    
                    test_level_playable();
                }
            }
            
            function convert_level_to_code() {
                return map.tiles.map(l => {
                    return l.map(t => {
                        switch (t) {
                            case null:
                                return " ";
                            case "wall":
                                return "#";
                            case "u-trap":
                                return "^";
                            case "d-trap":
                                return "V";
                            case "l-trap":
                                return ">";
                            case "r-trap":
                                return "<";
                            case "coin":
                                return "o";
                            case "goal":
                                return "$";
                            case "player":
                                return "@";
                        }
                    }).join("");
                });
            }
            
            document.getElementById("export").addEventListener("click", function() {
                // alert("look in the console.");
                
                var lines = convert_level_to_code();
                
                // console.log("[\"" + lines.join("\",\n\"") + "\"]");
                
                function create_element(tag, cl) {
                    var elt       = document.createElement(tag);
                    elt.className = cl;
                    return elt;
                }
                
                var export_dialog = create_element("div", "export-dialog");
                
                var export_text       = create_element("div", "export-text");
                export_text.innerHTML = "[\"" + lines.join("\",\n\"") + "\"]";
                
                var close_button       = create_element("button", "close");
                close_button.innerHTML = "close";
                close_button.addEventListener("click", function() {
                    document.body.removeChild(export_dialog);
                });
                
                export_dialog.appendChild(export_text);
                export_dialog.appendChild(close_button);
                
                document.body.appendChild(export_dialog);
            });
            
            // testing level mechanism
            var child_window = null;
            
            function map_has(tile) {
                return map.tiles.some(l => {
                    return l.some(t => {
                        return t == tile;
                    });
                });
            }
            
            function test_level_playable() {
                document.getElementById("test_level").disabled = !(map_has("player") && map_has("goal"));
            }
            
            // i still have no idea how these work.
            function post_delayed(child_window, message) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        child_window.postMessage(message, "*");
                        resolve("message posted to child window.");
                    }, 2000);
                });
            }
            
            async function call_async(action, params) {
                console.log("waiting...");
                console.log(await action.apply(null, params));
            }
            
            document.getElementById("test_level").addEventListener("click", () => {
                var grid     = convert_level_to_code();
                child_window = window.open("test_level.html", "Popup", "width=552,height=552,top=30,left=30");
                call_async(post_delayed, [child_window, grid]);
            });
            
            test_level_playable();
            
            requestAnimationFrame(animate);
        </script>
    </body>
</html>